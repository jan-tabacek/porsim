#' @importFrom dplyr %>% group_by summarise mutate ungroup arrange cumsum filter pull first select any_of across left_join rename case_when n_distinct last
#' @importFrom tidyr pivot_longer replace_na
#' @importFrom ggplot2 ggplot aes geom_col geom_line scale_y_continuous labs theme_minimal theme element_text scale_fill_manual scale_color_manual
#' @importFrom scales comma
NULL

#' Visualize the performance of a simulated portfolio over time.
#'
#' @description
#' This function generates a plot showing the outstanding principal balance
#' (split into "Normal" and "Past Due") and the cumulative cash flow, all on
#' a single y-axis.
#'
#' @param portfolio_history A tibble containing the full simulation results.
#' @return A ggplot object.
#' @export
portfolio_view <- function(portfolio_history) {

  # --- 1. Calculate Monthly Aggregates ---
  originated_amount <- portfolio_history %>%
    dplyr::filter(period == 1) %>%
    dplyr::group_by(period_date) %>%
    dplyr::summarise(total_originated = sum(initial_principal))

  monthly_summary <- portfolio_history %>%
    dplyr::group_by(period_date) %>%
    dplyr::summarise(
      past_due_balance = sum(closing_balance[status %in% c("Defaulted", "Sold")]),
      normal_balance = sum(closing_balance[!status %in% c("Defaulted", "Sold")]),
      incoming_payments = sum(payment),
      debt_sale_proceeds = sum(debt_sale_proceeds)
    ) %>%
    dplyr::ungroup() %>%
    dplyr::arrange(period_date) %>%
    dplyr::left_join(originated_amount, by = "period_date") %>%
    dplyr::mutate(total_originated = tidyr::replace_na(total_originated, 0))

  # --- 2. Prepare Data for Plotting ---
  plot_data <- monthly_summary %>%
    dplyr::mutate(
      net_cash_flow = (incoming_payments + debt_sale_proceeds) - total_originated,
      cumulative_cash_flow = cumsum(net_cash_flow),
      month = format(period_date, "%Y-%m")
    ) %>%
    dplyr::select(
      month,
      `Normal Balance` = normal_balance,
      `Past Due Balance` = past_due_balance,
      `Cumulative Cash Flow` = cumulative_cash_flow
    ) %>%
    tidyr::pivot_longer(
      cols = -month,
      names_to = "metric",
      values_to = "amount"
    )

  # --- 3. Create the Plot ---
  ggplot2::ggplot(plot_data, ggplot2::aes(x = month, y = amount, group = metric)) +
    # Draw the columns for balance types first
    ggplot2::geom_col(
      data = . %>% dplyr::filter(metric %in% c("Normal Balance", "Past Due Balance")),
      ggplot2::aes(fill = metric),
      position = "stack"
    ) +
    # Overlay the line for cash flow
    ggplot2::geom_line(
      data = . %>% dplyr::filter(metric == "Cumulative Cash Flow"),
      ggplot2::aes(color = metric),
      linewidth = 1.5
    ) +
    # --- Manual color and fill scales ---
    ggplot2::scale_fill_manual(
      name = "Balance Type",
      values = c("Normal Balance" = "steelblue", "Past Due Balance" = "firebrick")
    ) +
    ggplot2::scale_color_manual(
      name = "Performance",
      values = c("Cumulative Cash Flow" = "darkgreen")
    ) +
    ggplot2::scale_y_continuous(name = "Amount", labels = scales::comma) +
    ggplot2::labs(
      title = "Portfolio Performance Over Time",
      x = "Month",
      caption = "Generated by porsim package"
    ) +
    ggplot2::theme_minimal() +
    ggplot2::theme(
      plot.title = ggplot2::element_text(hjust = 0.5),
      legend.position = "bottom",
      legend.box = "horizontal",
      axis.text.x = ggplot2::element_text(angle = 45, hjust = 1)
    )
}





#' Calculate key performance metrics for a simulated portfolio.
#'
#' @param portfolio_history A tibble containing the full simulation results.
#' @return A tibble with a single row containing the calculated metrics.
#' @export
calculate_portfolio_metrics <- function(portfolio_history) {

  loan_summary <- portfolio_history %>%
    dplyr::group_by(loan_id) %>%
    dplyr::summarise(
      ever_defaulted = any(status == "Defaulted"),
      final_status = dplyr::last(status),
      .groups = "drop"
    )

  metrics <- loan_summary %>%
    dplyr::summarise(
      total_loans = dplyr::n_distinct(loan_id),

      # Paid on schedule without ever defaulting
      paid_on_time = sum(final_status == "Paid_Off" & !ever_defaulted),

      # NEW: Paid early without ever defaulting
      paid_off_early = sum(final_status == "Paid_Off_Early" & !ever_defaulted),

      # Paid, but only after having been in default at some point
      paid_after_default = sum(final_status %in% c("Paid_Off", "Paid_Off_Early") & ever_defaulted),

      # Ended in a "Sold" state
      defaulted_and_sold = sum(final_status == "Sold")
    )

  return(metrics)
}



#' Calculate key performance metrics for a simulated portfolio.
#'
#' @param portfolio_history A tibble containing the full simulation results.
#' @return A tibble with a single row containing the calculated metrics.
#' @export
calculate_portfolio_metrics_month <- function(portfolio_history) {

  loan_summary <- portfolio_history %>%
    dplyr::group_by(loan_id) %>%
    dplyr::summarise(
      vintage = min(vintage_date),
      ever_defaulted = any(status == "Defaulted"),
      final_status = dplyr::last(status),
      .groups = "drop"
    )

  metrics <- loan_summary %>%
    group_by(vintage) %>%
    dplyr::summarise(
      total_loans = dplyr::n_distinct(loan_id),

      # Paid on schedule without ever defaulting
      paid_on_time = sum(final_status == "Paid_Off" & !ever_defaulted),

      # NEW: Paid early without ever defaulting
      paid_off_early = sum(final_status == "Paid_Off_Early" & !ever_defaulted),

      # Paid, but only after having been in default at some point
      paid_after_default = sum(final_status %in% c("Paid_Off", "Paid_Off_Early") & ever_defaulted),

      # Ended in a "Sold" state
      defaulted_and_sold = sum(final_status == "Sold")
    )

  return(metrics)
}
